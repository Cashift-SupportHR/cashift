import 'package:injectable/injectable.dart';import 'package:shiftapp/core/bloc/base_cubit.dart';import '../../../../presentationUser/common/common_state.dart';import '../../data/models/index.dart';import '../../domain/entities/index.dart';@Injectable()class JobRequirementsCubit extends BaseCubit {  final JobRequirementsRepository _repository;  JobRequirementsCubit(this._repository);  StreamStateInitial<List<JobRequirements>?> jobRequirementsStream = StreamStateInitial();  List<JobRequirements> listJobRequirements = [];  fetchJobRequirements({required int type, String search = ''}) async {    jobRequirementsStream.setData(null);    try {      final result = await _repository.fetchJobRequirements(type: type);      final data = result.map((e) => JobRequirements.fromDto(e)).toList();      print('fetchJobRequirements $data');      listJobRequirements = data;     // jobRequirementsStream.setData(data);      searchByText(search);    } on Exception catch (e) {      print(e);      print("jkdvjknldvd");      jobRequirementsStream.setError(e);      // emit(ErrorState(e));    }  }  void searchByText(String value) {    List<JobRequirements> usersSearched = listJobRequirements;    try {      if(value.isNotEmpty && value != '0'){        usersSearched = listJobRequirements            .where((user) =>        (user.id != null && user.id!.toString().contains(value)) ||            (user.jobId != null && user.jobId!.toString().contains(value)) ||            (user.descriptionEn != null && user.descriptionEn!.contains(value)) ||            (user.descriptionAr != null && user.descriptionAr!.contains(value)))            .toList();      }    jobRequirementsStream.setData(usersSearched);    } on Exception catch (e) {      jobRequirementsStream.setError(e);    }  }  fetchJob({required int type}) async {    emit(LoadingState());    try {      final result = await _repository.fetchListJob();      final data = result.map((e) => JobModel.fromDto(e)).toList();      fetchJobRequirements(type: type);      emit(Initialized<List<JobModel>>(data: data));    } on Exception catch (e) {      emit(ErrorState(e));    }  }  deleteJobRequirements({required int id, required int type}) async {    try {      emit(LoadingStateListener());      final message = await _repository.deleteJobRequirements(id: id);      emit(SuccessStateListener(data: message));    } catch (e) {      emit(FailureStateListener(e));    }  }  addEditJobRequirements({required AddEditJobContaionPrams addEditJobContaionPrams, required int type}) async {    try {      emit(LoadingStateListener());      final message = await _repository.addEditJobRequirements(addEditJobContaionPrams: addEditJobContaionPrams);      emit(SuccessStateListener(data: message));    } catch (e) {      emit(FailureStateListener(e));    }  }}