import 'package:injectable/injectable.dart';import 'package:shiftapp/core/bloc/base_cubit.dart';import '../../../../../presentationUser/common/common_state.dart';import '../../../data/models/index.dart';import '../../../domain/entities/index.dart';@Injectable()class AddPunishmentCubit extends BaseCubit {   final PunishmentsRepository _repository;   AddPunishmentCubit(this._repository);   Future<void> addEditPunishment(AddEditPunishmentParams params) async {     executeEmitterListener(() => _repository.addEditPunishment(params));   }   Future<void> fetchInitialData({int? id}) async{     AddEditPunishmentParams? params = AddEditPunishmentParams();     executeBuilder(() => fetchPunishmentsNames() , onSuccess: (punishmentsNames) async {        params =  id == null ? null :       await _repository.fetchPunishmentById(id);       final punishmentsTypes = await fetchPunishmentsTypes();       emit(InitializedAddPunishment(         punishmentsNames: punishmentsNames,             punishmentsTypes: punishmentsTypes,         addEditPunishmentParams: params,       ));     });   }   Future<List<PunishmentName>> fetchPunishmentsNames() async{    final punishmentsNamesDto =  await _repository.fetchPunishmentsNames();    final punishmentsNames = punishmentsNamesDto.map((e) => PunishmentName.fromDto(e)).toList();     return punishmentsNames;   }   Future<List<PunishmentType>> fetchPunishmentsTypes() async{     final punishmentsTypesDto =  await _repository.fetchPunishmentsTypes();     final punishmentsTypes = punishmentsTypesDto.map((e) => PunishmentType.fromDto(e)).toList();     return punishmentsTypes;   }}