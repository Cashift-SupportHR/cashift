import 'package:injectable/injectable.dart';import 'package:shiftapp/core/bloc/base_cubit.dart';import 'package:shiftapp/presentation/adminFeatures/projectsManagement/data/repositories/projects_management_repository.dart';import 'package:shiftapp/presentation/presentationUser/common/common_state.dart';import '../../../projectsManagement/domain/entities/job.dart';import '../../../usersManagement/domain/entities/company.dart';import '../../data/models/add_job_uniform_params.dart';import '../../data/models/uniform_dto.dart';import '../../data/repositories/job_uniform_repository.dart';import '../../domain/entities/Uniform.dart';import '../../domain/entities/job_uniform_type.dart';@Injectable()class AddJobUniformCubit extends BaseCubit {  final JobUniformRepository _repository;  final ProjectsManagementRepository _projectsRepository;  AddJobUniformCubit(this._repository, this._projectsRepository);  StreamStateInitial<List<Uniform>?> jobUniformTypeStream =      StreamStateInitial();  StreamStateInitial<List<Job>?> jobStream =      StreamStateInitial();  StreamStateInitial<List<Company>?> companyStream =      StreamStateInitial();  Future<void> addJobUniform(AddJobUniformParams params) async {    executeEmitterListener(() => _repository.addJobUniform(params));  }  Future<void> fetchInitialData() async {    try {      final jobDto = await _projectsRepository.fetchCompanies( );      companyStream.setData(jobDto);    } on Exception catch (e) {      companyStream.setError(e);    }    // executeBuilder(() => _projectsRepository.fetchCompanies(),    //     onSuccess: (company) async {    //   emit(Initialized<List<Company>>(data: company));    // });  }  Future<void> fetchJobData( ) async {    // jobStream.setData(null);    try {      final jobDto = await _projectsRepository.fetchAllJobForDrops( );      final jobs = jobDto.map((e) => Job.fromDto(e)).toList();      jobStream.setData(jobs);    } on Exception catch (e) {      jobStream.setError(e);    }  }  Future<void> fetchJobUniform(int jobId,int companyId) async {    jobUniformTypeStream.setData(null);    try {      final jobUniformTypeDto = await _repository.fetchJobUniform(jobId,companyId);      final JobUniform =          jobUniformTypeDto.map((e) => Uniform.fromDto(e)).toList();      jobUniformTypeStream.setData(JobUniform);    } on Exception catch (e) {      jobUniformTypeStream.setError(e);    }  }  deleteJobUniform(int id) async {    executeEmitterListener(() =>   _repository.deleteJobUniform(id));  }}