import 'package:injectable/injectable.dart';import 'package:shiftapp/core/bloc/base_cubit.dart';import '../../../../../presentationUser/common/common_state.dart';import '../../../data/models/index.dart';import '../../../domain/entities/index.dart';@Injectable()class AddWorkingPeriodCubit extends BaseCubit {  final ProjectsManagementRepository _repository;  AddWorkingPeriodCubit(this._repository);  Future<void> addEditWorkingPeriod(AddWorkingPeriodParams params) async {    emit(LoadingStateListener());    try {      final message = await _repository.addEditWorkingPeriod(params);      emit(SuccessStateListener(data: message));      // if(params.id == 0){      //   emit(FinishedDialogState<int>(message: response.payload));      // } else {      //   emit(FinishedDialogState<String>(message: response.message.toString()));      // }    } catch (e) {      emit(FailureStateListener(e));    }  }  Future<void> fetchWorkingPeriodsByProjectId(int? projectId) async {    emit(LoadingState());    try {      final response =          await _repository.fetchWorkingPeriodsByProjectId(projectId);      final workingPeriods =          response.map((e) => WorkingPeriod.fromDto(e)).toList();      emit(        Initialized<List<WorkingPeriod>>(data: workingPeriods),      );    } on Exception catch (e) {      emit(ErrorState(e));    }  }  Future<void> fetchAllaData({int? id}) async {    AddWorkingPeriodParams workingPeriodInfo = AddWorkingPeriodParams();    emit(LoadingState());    try {      workingPeriodInfo = id == null          ? AddWorkingPeriodParams()          : await fetchWorkingPeriodDetails(id);      final labels = await fetchWorkingPeriodLabels();      final periodOrder = await fetchPeriodOrder();      final occupations = await fetchAllJobForDrops();      emit(        InitializedAddWorkingPeriod(          workingPeriodInfo: workingPeriodInfo,          labels: labels,          periodOrder: periodOrder,          occupations: occupations,        ),      );    } on Exception catch (e) {      emit(ErrorState(e));    }  }  Future<List<PeriodOrder>> fetchPeriodOrder() async {    final response = await _repository.fetchPeriodOrder();    List<PeriodOrder> brands =        response.map((e) => PeriodOrder.fromDto(e)).toList();    return brands;  }  Future<List<Job>> fetchAllJobForDrops() async {    final response = await _repository.fetchAllJobForDrops();    List<Job> cities =        response.map((e) => Job.fromDto(e)).toList();    return cities;  }  Future<WorkingPeriodLabels> fetchWorkingPeriodLabels() async {    final response = await _repository.fetchWorkingPeriodLabels();    return WorkingPeriodLabels.fromDto(response);  }  Future<AddWorkingPeriodParams> fetchWorkingPeriodDetails(int id) async {    final response = await _repository.fetchWorkingPeriodDetails(id);    return response;  }  Future<void> deleteWorkingPeriod(int? id) async {    emit(LoadingStateListener());    try {      final message = await _repository.deleteWorkingPeriod(id);      emit(SuccessStateListener(data: message));    } catch (e) {      emit(FailureStateListener(e));    }  }}