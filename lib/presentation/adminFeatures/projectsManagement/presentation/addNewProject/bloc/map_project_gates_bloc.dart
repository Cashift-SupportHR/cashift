import 'package:geolocator/geolocator.dart';import 'package:google_maps_flutter/google_maps_flutter.dart';import 'package:injectable/injectable.dart';import 'package:shiftapp/core/bloc/base_cubit.dart';import 'dart:async';import 'dart:io';import 'dart:ui' as ui;import 'package:flutter/material.dart';import 'package:flutter/services.dart';import 'package:shiftapp/presentation/presentationUser/common/common_state.dart';import '../../../../../presentationUser/resources/colors.dart';import '../../../../../presentationUser/resources/constants.dart';import '../../../data/models/employe_point_dto.dart';import '../../../data/models/location_gate_project_dto.dart';import '../../../data/repositories/projects_management_repository.dart';@Injectable()class MapProjectGatesCubit extends BaseCubit {  final ProjectsManagementRepository _repository;  MapProjectGatesCubit(this._repository);  Future<Position> _determinePosition() async {    bool serviceEnabled;    LocationPermission permission;    // Test if location services are enabled.    serviceEnabled = await Geolocator.isLocationServiceEnabled();    if (!serviceEnabled) {      // Location services are not enabled don't continue      // accessing the position and request users of the      // App to enable the location services.      return Future.error('Location services are disabled.');    }    permission = await Geolocator.checkPermission();    if (permission == LocationPermission.denied) {      permission = await Geolocator.requestPermission();      if (permission == LocationPermission.denied) {        Geolocator.openAppSettings();        // Permissions are denied, next time you could try        // requesting permissions again (this is also where        // Android's shouldShowRequestPermissionRationale        // returned true. According to Android guidelines        // your App should show an explanatory UI now.        return Future.error('Location permissions are denied');      }    }    if (permission == LocationPermission.deniedForever) {      // Permissions are denied forever, handle appropriately.      Geolocator.openAppSettings();      return Future.error(          'Location permissions are permanently denied, we cannot request permissions.');    }    // When we reach here, permissions are granted and we can    // continue accessing the position of the device.    return await Geolocator.getCurrentPosition(        desiredAccuracy: LocationAccuracy.high);  }  LatLng? lastUserLocation;  GoogleMapController? mapController;  detectMyLocation() async {    if (lastUserLocation != null) {      final p = CameraPosition(          target:              LatLng(lastUserLocation!.latitude, lastUserLocation!.longitude),          zoom: 6);      mapController?.animateCamera(CameraUpdate.newCameraPosition(p));    }    print('detectMyLocation');    _determinePosition().then((value) {      print('detectMyLocation focusToPosition');      focusToPosition(value);    }, onError: (e) async {      await Geolocator.openLocationSettings();    });  }  focusToPosition(Position position) {    final p = CameraPosition(        target: LatLng(position.latitude, position.longitude), zoom: 6);    lastUserLocation = LatLng(position.latitude, position.longitude);    mapController?.animateCamera(CameraUpdate.newCameraPosition(p));  }  Future<BitmapDescriptor> createCustomMarkerBitmapWithNameAndImage(      {required Size size,      required String name,      required String description}) async {    TextSpan span = new TextSpan(      children: [        TextSpan(          text: name,          style: kTextMedium.copyWith(            color: Colors.white,            overflow: TextOverflow.ellipsis,            fontSize: 22.0,          ),        ),        TextSpan(          text: description,          style: kTextRegular.copyWith(            color: Colors.white,            fontSize: 18.0,          ),        ),      ],    );    TextPainter tp = new TextPainter(      text: span,      textAlign: TextAlign.center,      textDirection: TextDirection.rtl,    );    tp.layout();    ui.PictureRecorder recorder = new ui.PictureRecorder();    Canvas canvas = new Canvas(recorder);    final double shadowWidth = 15.0;    final double borderWidth = 3.0;    final double imageOffset = shadowWidth + borderWidth;    // TEXT BOX BACKGROUND    Paint textBgBoxPaint = Paint()..color = kPrimary;    Rect rect = Rect.fromCenter(           center: ui.Offset(40, 10), width: tp.width+80,height:tp.height+50 ,    );    canvas.drawRRect(      RRect.fromRectAndRadius(rect, Radius.circular(10.0),),      textBgBoxPaint,    );    //ADD TEXT WITH ALIGN TO CANVAS    tp.paint(canvas, new Offset(5.0, 5.0));    /* Do your painting of the custom icon here, including drawing text, shapes, etc. */    Rect oval = Rect.fromLTWH(tp.width / 3.7, 75,        size.width - (imageOffset * 2), size.height - (imageOffset * 2));    // ADD  PATH TO OVAL IMAGE    canvas.clipPath(Path()..addOval(oval));    ui.Image image = await getImageFromAssets();    paintImage(canvas: canvas, image: image, rect: oval, fit: BoxFit.contain);    ui.Picture p = recorder.endRecording();    ByteData? pngBytes = await (await p.toImage(200, 200))        .toByteData(format: ui.ImageByteFormat.png);    Uint8List data = Uint8List.view(pngBytes!.buffer);    return BitmapDescriptor.fromBytes(data);  }  Future<ui.Image> getImageFromAssets() async {    // Load the image data from assets as ByteData    final ByteData data = await rootBundle.load("assets/icons/pin2.png");    // Convert ByteData to Uint8List    final Uint8List bytes = data.buffer.asUint8List();    // Use Completer to decode the image    final Completer<ui.Image> completer = Completer();    // Decode the image from the list of bytes    ui.decodeImageFromList(bytes, (ui.Image img) {      completer.complete(img);    });    // Return the future of the completed image    return completer.future;  }  Future<BitmapDescriptor> getMarkerIcon(      {required String name, required String description}) async {    Size s = Size(100, 100);    var icon = await createCustomMarkerBitmapWithNameAndImage(        size: s, description: description, name: name);    return icon;  }  fetchLocationGateProject(int projectId) {    executeBuilder(() => _repository.fetchLocationGateProject(projectId),        onSuccess: (result) {      emit(Initialized<LocationGateProjectDto>(data: result));    });  }  fetchEmpLocationGate(String pointId) {    executeBuilder(() => _repository.fetchEmpLocationGate(pointId: pointId),        onSuccess: (result) {      emit(Initialized<List<EmployePointDto>>(data: result));    });  }}