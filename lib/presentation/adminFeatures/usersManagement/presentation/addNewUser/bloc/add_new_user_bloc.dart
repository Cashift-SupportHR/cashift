import 'package:injectable/injectable.dart';import 'package:shiftapp/core/bloc/base_cubit.dart';import '../../../../../presentationUser/common/common_state.dart';import '../../../../../presentationUser/common/stream_data_state.dart';import '../../../../../shared/models/common_list_item.dart';import '../../../../focusPoints/data/repositories/focus_points_repository.dart';import '../../../../focusPoints/domain/entities/shifts_by_project.dart';import '../../../../projectsManagement/data/repositories/projects_management_repository.dart';import '../../../data/models/index.dart';import '../../../data/models/user_by_phone_dto.dart';import '../../../domain/entities/index.dart';@Injectable()class AddNewUserCubit extends BaseCubit {  final UsersManagementRepository _repository;  final ProjectsManagementRepository _projectsRepository;  final FocusPointsRepository _focusPointsRepository;  AddNewUserCubit(      this._repository, this._projectsRepository, this._focusPointsRepository);  StreamStateInitial<List<ShiftsByProject>?> shiftsStream =      StreamStateInitial();  StreamStateInitial<List<CommonListItem>?> projectsStream =      StreamStateInitial();  StreamDataStateInitial<UserByPhoneDto?> userByPhoneStream =      StreamDataStateInitial();  StreamStateInitial<List<Brand>?> brandsStream = StreamStateInitial();  Future<void> addNewUser(AddNewUserParams params) async {    executeEmitterListener(() => params.id == null        ? _repository.addNewUser(params)        : _repository.updateUserData(params));  }  Future<void> fetchAllaData(String? phoneNumber) async {    emit(LoadingState());    try {      final infoUserManager = await fetchInfoUserManager();      final companies = await _projectsRepository.fetchCompanies();      final areas = await fetchAllUserAreas();      if(phoneNumber != null){        fetchEmpByPhone(phoneNumber ?? "");      }      emit(InitializedAddNewUser(        infoUserManager: infoUserManager,        projects: [],        brands: [],        companies: companies,        areas: areas,      ));    } on Exception catch (e) {      emit(ErrorState(e));    }  }  Future<InfoUserManager> fetchInfoUserManager() async {    final result = await _repository.fetchInfoUserManager();    return InfoUserManager.fromDto(result);  }  Future<void> fetchListProjectsByCompanyId(int CompanyId) async {    projectsStream.setData(null);    try {      final projects =          await _repository.fetchListProjectsByCompanyId(CompanyId);      projectsStream.setData(projects);    } on Exception catch (e) {      projectsStream.setError(e);    }  }  Future<void> fetchShiftByListProjectId(int projectId) async {    shiftsStream.setData(null);    try {      print('projectIds $projectId');      final response =          await _focusPointsRepository.fetchShiftsByProjectId(projectId);      List<ShiftsByProject> shifts =          response.map((e) => ShiftsByProject.fromJson(e)).toList();      shiftsStream.setData(shifts);    } catch (e) {      print('error $e');      shiftsStream.setError(e);    }  }  Future<void> fetchBrandsByCompanyId(int CompanyId) async {    brandsStream.setData(null);    try {      final response = await _repository.fetchBrands(CompanyId);      List<Brand> brands = response.map((e) => Brand.fromDto(e)).toList();      brandsStream.setData(brands);    } on Exception catch (e) {      brandsStream.setError(e);    }  }  Future<List<UserArea>> fetchAllUserAreas() async {    final response = await _repository.fetchAllUserAreas();    List<UserArea> areas = response.map((e) => UserArea.fromDto(e)).toList();    return areas;  }  Future<void> fetchEmpByPhone(String phoneOrIdNumber) async {    try {      final user = await _repository.fetchUserByPhone(phoneOrIdNumber);      userByPhoneStream.setData(user);    } on Exception catch (e) {      userByPhoneStream.setError(e);    }  }}