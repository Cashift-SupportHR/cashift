import 'package:injectable/injectable.dart';import 'package:shiftapp/core/bloc/base_cubit.dart';import 'package:shiftapp/presentation/adminFeatures/usersManagement/domain/entities/company.dart';import '../../../../../../presentationUser/common/common_state.dart';import '../../../../../projectsManagement/data/repositories/projects_management_repository.dart';import '../../../../data/models/index.dart';import '../../../../domain/entities/TermandCondition.dart';@Injectable()class TermsAndConditionsCubit extends BaseCubit {  final TermandConditionRepository _repository;  final ProjectsManagementRepository projectsManagementRepository;  TermsAndConditionsCubit(this._repository, this.projectsManagementRepository);  StreamStateInitial<List<TermandCondition>?> termandCondition = StreamStateInitial();  List<TermandCondition> listTermandCondition = [];  fetchInitialData({required int type}) async {    executeBuilder(() => _repository.fetchTermandCondition(type: type), onSuccess: (result) {      listTermandCondition = result.map((e) => TermandCondition.fromDto(e)).toList();      emit(Initialized<List<TermandCondition>>(data: listTermandCondition));    });  }  // List<CompanyProject>  /*   final response = await _repository.fetchCompanies();    List<CompanyProject> company = response.map((e) => CompanyProject.fromDto(e)).toList();   */  fetchCompany() async {    executeBuilder(() => projectsManagementRepository.fetchCompanies(), onSuccess: (companies) {      emit(Initialized<List<Company>>(data: companies));    });  }  void searchByText(String value) {    try {      List<TermandCondition> usersSearched = listTermandCondition;      if (value.isNotEmpty) {        usersSearched = listTermandCondition            .where((user) =>                (user.id != null && user.id!.toString().contains(value)) ||                (user.conditionEn != null && user.conditionEn!.contains(value)) ||                (user.conditionAr != null && user.conditionAr!.contains(value)))            .toList();      }      termandCondition.setData(usersSearched);    } on Exception catch (e) {      print(e);      termandCondition.setError(e);    }  }  fetchTermsAndConditions({required int type}) async {    termandCondition.setData(null);    try {      final result = await _repository.fetchTermandCondition(type: type);      listTermandCondition = result.map((e) => TermandCondition.fromDto(e)).toList();      termandCondition.setData(listTermandCondition);    } on Exception catch (e) {      termandCondition.setError(e);    }  }  deleteTermandCondition({required int id, required int type}) async {    try {      emit(LoadingStateListener());      final message = await _repository.deleteTermandCondition(id: id);      emit(SuccessStateListener(data: message));    } catch (e) {      emit(FailureStateListener(e));    }  }  updateType({required int id, required int type}) async {    try {      emit(LoadingStateListener());      final message = await _repository.updateType(id: id);      emit(SuccessStateListener(data: message));    } catch (e) {      emit(FailureStateListener(e));    }  }  addEditTermandCondition({required TermsAndConditionsPrams termsAndConditionsPrams}) async {    try {      emit(LoadingStateListener());      final message = await _repository.addEditTermandCondition(termsAndConditionsPrams: termsAndConditionsPrams);      emit(SuccessStateListener(data: message));    } catch (e) {      emit(FailureStateListener(e));    }  }}