import 'package:injectable/injectable.dart';import 'package:shiftapp/core/bloc/base_cubit.dart';import 'package:shiftapp/presentation/adminFeatures/usersManagement/domain/entities/company.dart';import '../../../../../../presentationUser/common/common_state.dart';import '../../../../../projectsManagement/data/models/index.dart';import '../../../../data/models/index.dart';import '../../../../domain/entities/TermandCondition.dart';@Injectable()class TasksAndResponsibilitiesCubit extends BaseCubit {  final TermandConditionRepository _repository;  final ProjectsManagementRepository projectsManagementRepository;  TasksAndResponsibilitiesCubit(this._repository, this.projectsManagementRepository);  StreamStateInitial<List<TermandCondition>?> termandCondition = StreamStateInitial();  List<TermandCondition> listTermandCondition = [];  fetchInitialData({required int type}) async {    executeBuilder(() => _repository.fetchTasks(type), onSuccess: (result) {      listTermandCondition = result.map((e) => TermandCondition.fromDto(e)).toList();      emit(Initialized<List<TermandCondition>>(data: listTermandCondition));    });  }  void searchByText(String value) {    try {      List<TermandCondition> usersSearched = listTermandCondition;      if (value.isNotEmpty) {        usersSearched = listTermandCondition            .where((user) =>                (user.id != null && user.id!.toString().contains(value)) ||                (user.conditionEn != null && user.conditionEn!.contains(value)) ||                (user.conditionAr != null && user.conditionAr!.contains(value)))            .toList();      }      termandCondition.setData(usersSearched);    } on Exception catch (e) {      print(e);      termandCondition.setError(e);    }  }  deleteTermandCondition({required int id, required int type}) async {    try {      emit(LoadingStateListener());      final message = await _repository.deleteTermandCondition(id: id);      emit(SuccessStateListener(data: message));    } catch (e) {      emit(FailureStateListener(e));    }  }  updateType({required int id, required int type}) async {    try {      emit(LoadingStateListener());      final message = await _repository.updateType(id: id);      emit(SuccessStateListener(data: message));    } catch (e) {      emit(FailureStateListener(e));    }  }  addEditTermandCondition({required TermsAndConditionsPrams termsAndConditionsPrams}) async {    try {      emit(LoadingStateListener());      final message = await _repository.addEditTermandCondition(termsAndConditionsPrams: termsAndConditionsPrams);      emit(SuccessStateListener(data: message));    } catch (e) {      emit(FailureStateListener(e));    }  }}