import 'package:injectable/injectable.dart';import 'package:shiftapp/core/bloc/base_cubit.dart';import 'package:shiftapp/presentation/presentationUser/vehiclesOperation/presentation/startTour/bloc/start_tour_state.dart';import '../../../../../common/common_state.dart';import '../../../../../common/stream_data_state.dart';import '../../../../data/models/index.dart';import '../../../../data/repositories/vehicles_operation_repository.dart';import '../../../../domain/entities/index.dart';@Injectable()class ChangeOperatingPlaneCubit extends BaseCubit {  final ReceiveVehiclesRepository _repository;  ChangeOperatingPlaneCubit(this._repository);  StreamDataStateInitial<List<RoundTypeTermsAndCondition>?> roundTypeTermsAndConditionStream =  StreamDataStateInitial<List<RoundTypeTermsAndCondition>?>();  void fetchInitialData(CurrentRoundTrip currentRoundTrip) async {    executeBuilder(() => _repository.fetchAllFreeLancerVehiclesZones(),        onSuccess: (vehiclesZones) async {          final roundTypes =          await _repository.fetchAllRoundTypes();           fetchRoundTypeTermsAndCondition(currentRoundTrip.roundTypeId ?? 0);          emit(Initialized<StartTourState>(              data: StartTourState(                vehiclesZones: vehiclesZones,                roundTypes: roundTypes,                roundTypeTermsAndConditionStream: roundTypeTermsAndConditionStream,              )));        });  }  void fetchRoundTypeTermsAndCondition(int roundTypeId) async {    try {      final response =      await _repository.fetchRoundTypeTermsAndCondition(roundTypeId);      roundTypeTermsAndConditionStream.setData(response);    } catch (e) {      roundTypeTermsAndConditionStream.setError(e);      rethrow;    }  }  void addRoundTripDetails(AddRoundTripDetailsParams params) async {    executeEmitterListener(() => _repository.addRoundTripDetails(params));  }}