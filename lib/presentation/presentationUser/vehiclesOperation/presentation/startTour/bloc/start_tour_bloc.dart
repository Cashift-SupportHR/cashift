import 'package:injectable/injectable.dart';import 'package:shiftapp/core/bloc/base_cubit.dart';import 'package:shiftapp/presentation/presentationUser/vehiclesOperation/presentation/startTour/bloc/start_tour_state.dart';import '../../../../common/common_state.dart';import '../../../../common/stream_data_state.dart';import '../../../data/models/index.dart';import '../../../data/repositories/vehicles_operation_repository.dart';import '../../../domain/entities/index.dart';@Injectable()class StartTourCubit extends BaseCubit {  final ReceiveVehiclesRepository _repository;  StartTourCubit(this._repository);  StreamDataStateInitial<List<RoundTypeTermsAndCondition>?> roundTypeTermsAndConditionStream =  StreamDataStateInitial<List<RoundTypeTermsAndCondition>?>();  void fetchInitialData() async {    executeBuilder(() => _repository.fetchAllFreeLancerVehiclesZones(),        onSuccess: (vehiclesZones) async {          final roundTypes =          await _repository.fetchAllRoundTypes();          emit(Initialized<StartTourState>(              data: StartTourState(                vehiclesZones: vehiclesZones,                roundTypes: roundTypes,                roundTypeTermsAndConditionStream: roundTypeTermsAndConditionStream,              )));        });  }  void fetchRoundTypeTermsAndCondition(int roundTypeId) async {    try {      final response =      await _repository.fetchRoundTypeTermsAndCondition(roundTypeId);      roundTypeTermsAndConditionStream.setData(response);    } catch (e) {      roundTypeTermsAndConditionStream.setError(e);      rethrow;    }  }  void addRoundTrip(AddRoundTripParams params) async {    executeEmitterListener(() => _repository.addRoundTrip(params));  }}